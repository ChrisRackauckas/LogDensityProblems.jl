<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Documentation · LogDensityProblems.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>LogDensityProblems.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Documentation</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#Working-with-log-density-problems-1">Working with log density problems</a></li><li><a class="toctext" href="#Using-the-TransformVariables-package-1">Using the TransformVariables package</a></li><li><a class="toctext" href="#Manual-unpacking-and-transformation-1">Manual unpacking and transformation</a></li><li><a class="toctext" href="#Automatic-differentiation-1">Automatic differentiation</a></li><li><a class="toctext" href="#Manually-calculated-derivatives-1">Manually calculated derivatives</a></li><li class="toplevel"><a class="toctext" href="#Various-utilities-1">Various utilities</a></li><li class="toplevel"><a class="toctext" href="#log-density-api-1">Log densities API</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Documentation</a></li></ul><a class="edit-page" href="https://github.com/tpapp/LogDensityProblems.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Documentation</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Introduction-1" href="#Introduction-1">Introduction</a></h1><p>This package serves two purposes:</p><ol><li><p>Introduce a common API for packages that operate on <em>log densities</em>, which for these purposes are black box <span>$\mathbb{R}^n \to \mathbb{R}$</span> mappings. Using the interface of introduced in this package, you can query <span>$n$</span>, evaluate the log density and optionally its gradient, and determine if a particular object supports these methods using traits. <strong>This usage is relevant primarily for package developers</strong> who write generic algorithms that use (log) densities that correspond to posteriors and likelihoods, eg <a href="https://en.wikipedia.org/wiki/Markov_chain_Monte_Carlo">MCMC</a>, <a href="https://en.wikipedia.org/wiki/Maximum_a_posteriori_estimation">MAP</a>, <a href="https://en.wikipedia.org/wiki/Maximum_likelihood_estimation">ML</a>. An example is <a href="https://github.com/tpapp/DynamicHMC.jl">DynamicHMC.jl</a>. This is documented in <a href="#log-density-api-1">the API section</a>.</p></li><li><p>Make it easier for <strong>users who want to perform inference</strong> using the above methods (and packages) to</p><ul><li><em>define their own log densities</em>, either taking a vector of real numbers as input, or extracting and transforming parameters using the <a href="https://github.com/tpapp/TransformVariables.jl">TransformVariables.jl</a> package,</li><li><em>obtain gradients</em> of these log densities using one of the supported <em>automatic differentiation</em> packages of Julia.</li></ul></li></ol><p>This is documented in the next section, with a worked example.</p><p>For the purposes of this package, <em>log densities</em> are still valid when shifted by a constant that may be unknown, but is consistent within calls. This is necessary for Bayesian inference, where log posteriors are usually calculated up to a constant. See <a href="#LogDensityProblems.logdensity"><code>LogDensityProblems.logdensity</code></a> for details.</p><h1><a class="nav-anchor" id="Working-with-log-density-problems-1" href="#Working-with-log-density-problems-1">Working with log density problems</a></h1><p>Consider an inference problem where IID draws are obtained from a normal distribution,</p><div>\[x_i \sim N(\mu, \sigma)\]</div><p>for <span>$i = 1, \dots, N$</span>. It can be shown that the <em>log likelihood</em> conditional on <span>$\mu$</span> and <span>$\sigma$</span> is</p><div>\[\ell = -N\log \sigma - \sum_{i = 1}^N \frac{(x-\mu)^2}{2\sigma^2} =
-N\left( \log \sigma + \frac{S + (\bar{x} - \mu)^2}{2\sigma^2} \right)\]</div><p>where we have dropped constant terms, and defined the sufficient statistics</p><div>\[\bar{x} = \frac{1}{N} \sum_{i = 1}^N x_i\]</div><p>and</p><div>\[S = \frac{1}{N} \sum_{i = 1}^N (x_i - \bar{x})^2\]</div><p>Finally, we use priors</p><div>\[\mu \sim N(0, 5), \sigma \sim N(0, 2)\]</div><p>which yield the log prior</p><div>\[-\sigma^2/8 - \mu^2/50\]</div><p>which is added to the log likelihood to obtain the log posterior.</p><p>It is useful to define a <em>callable</em> that implements this, taking some vector <code>x</code> as an input and calculating the summary statistics, then, when called with a <code>NamedTuple</code> containing the parameters, evaluating to the log posterior.</p><pre><code class="language-">using Random; Random.seed!(1) # hide
using Statistics, Parameters # imported for our implementation

struct NormalPosterior{T} # contains the summary statistics
    N::Int
    x̄::T
    S::T
end

# calculate summary statistics from a data vector
function NormalPosterior(x::AbstractVector)
    NormalPosterior(length(x), mean(x), var(x; corrected = false))
end

# define a callable that unpacks parameters, and evaluates the log likelihood
function (problem::NormalPosterior)(θ)
    @unpack μ, σ = θ
    @unpack N, x̄, S = problem
    loglikelihood = -N * (log(σ) + (S + abs2(μ - x̄)) / (2 * abs2(σ)))
    logprior = - abs2(σ)/8 - abs2(μ)/50
    loglikelihood + logprior
end

problem = NormalPosterior(randn(100))
nothing # hide</code></pre><p>Let&#39;s try out the posterior calculation:</p><pre><code class="language-julia-repl">julia&gt; problem((μ = 0.0, σ = 1.0))
ERROR: UndefVarError: problem not defined</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Just evaluating your log density function like above is a great way to test and benchmark your implementation. See the “Performance Tips” section of the Julia manual for optimization advice.</p></div></div><h2><a class="nav-anchor" id="Using-the-TransformVariables-package-1" href="#Using-the-TransformVariables-package-1">Using the TransformVariables package</a></h2><p>In our example, we require <span>$\sigma &gt; 0$</span>, otherwise the problem is meaningless. However, many MCMC samplers prefer to operate on <em>unconstrained</em> spaces <span>$\mathbb{R}^n$</span>. The TransformVariables package was written to transform unconstrained to constrained spaces, and help with the log Jacobian correction (more on that later). That package has detailed documentation, now we just define a transformation from a length 2 vector to a <code>NamedTuple</code> with fields <code>μ</code> (unconstrained) and <code>σ &gt; 0</code>.</p><pre><code class="language-julia-repl">julia&gt; using LogDensityProblems, TransformVariables
ERROR: ArgumentError: Package TransformVariables not found in current path:
- Run `import Pkg; Pkg.add(&quot;TransformVariables&quot;)` to install the TransformVariables package.

julia&gt; ℓ = TransformedLogDensity(as((μ = asℝ, σ = asℝ₊)), problem)
ERROR: UndefVarError: asℝ not defined</code></pre><p>Then we can query the dimension of this problem, and evaluate the log density:</p><pre><code class="language-julia-repl">julia&gt; LogDensityProblems.dimension(ℓ)
ERROR: UndefVarError: ℓ not defined

julia&gt; LogDensityProblems.logdensity(ℓ, zeros(2))
ERROR: UndefVarError: ℓ not defined</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Before running time-consuming algorithms like MCMC, it is advisable to test and benchmark your log density evaluations separately. The same applies to <a href="#LogDensityProblems.logdensity_and_gradient"><code>LogDensityProblems.logdensity_and_gradient</code></a>.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LogDensityProblems.TransformedLogDensity" href="#LogDensityProblems.TransformedLogDensity"><code>LogDensityProblems.TransformedLogDensity</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">TransformedLogDensity(transformation, log_density_function)</code></pre><p>A problem in Bayesian inference. Vectors of length compatible with the dimension (obtained from <code>transformation</code>) are transformed into a general object <code>θ</code> (unrestricted type, but a named tuple is recommended for clean code), correcting for the log Jacobian determinant of the transformation.</p><p><code>log_density_function(θ)</code> is expected to return <em>real numbers</em>. For zero densities or infeasible <code>θ</code>s, <code>-Inf</code> or similar should be returned, but for efficiency of inference most methods recommend using <code>transformation</code> to avoid this. It is recommended that <code>log_density_function</code> is a callable object that also encapsulates the data for the problem.</p><p>Use the property accessors <code>ℓ.transformation</code> and <code>ℓ.log_density_function</code> to access the arguments of <code>ℓ::TransformedLogDensity</code>, these are part of the API.</p><p><strong>Usage note</strong></p><p>This is the most convenient way to define log densities, as <code>capabilities</code>, <code>logdensity</code>, and <code>dimension</code> are automatically defined. To obtain a type that supports derivatives, use <a href="#LogDensityProblems.ADgradient"><code>ADgradient</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tpapp/LogDensityProblems.jl/blob/d7a3e8e82f6090efca84668764e767e10a463c2f/src/LogDensityProblems.jl#L131-L152">source</a></section><h2><a class="nav-anchor" id="Manual-unpacking-and-transformation-1" href="#Manual-unpacking-and-transformation-1">Manual unpacking and transformation</a></h2><p>If you prefer to implement the transformation yourself, you just have to define the following three methods for your problem: declare that it can evaluate log densities (but not their gradient, hence the <code>0</code> order), allow the dimension of the problem to be queried, and then finally code the density calculation with the transformation. (Note that using <a href="#LogDensityProblems.TransformedLogDensity"><code>TransformedLogDensity</code></a> takes care of all of these for you, as shown above).</p><pre><code class="language-">function LogDensityProblems.capabilities(::Type{&lt;:NormalPosterior})
    LogDensityProblems.LogDensityOrder{0}()
end

LogDensityProblems.dimension(::NormalPosterior) = 2

function LogDensityProblems.logdensity(problem::NormalPosterior, x)
    μ, logσ = x
    σ = exp(logσ)
    problem((μ = μ, σ = σ)) + logσ
end
nothing # hide</code></pre><pre><code class="language-julia-repl">julia&gt; LogDensityProblems.logdensity(problem, zeros(2))
ERROR: UndefVarError: problem not defined</code></pre><p>Here we use the exponential function to transform from <span>$\mathbb{R}$</span> to the positive reals, but this requires that we correct the log density with the <em>logarithm</em> of the Jacobian, which here happens to be <span>$\log(\sigma)$</span>.</p><h2><a class="nav-anchor" id="Automatic-differentiation-1" href="#Automatic-differentiation-1">Automatic differentiation</a></h2><p>Using either definition, you can now transform to another object which is capable of evaluating the <em>gradient</em>, using automatic differentiation. The wrapper for this is</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LogDensityProblems.ADgradient" href="#LogDensityProblems.ADgradient"><code>LogDensityProblems.ADgradient</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">ADgradient(kind, P; kwargs...)
</code></pre><p>Wrap <code>P</code> using automatic differentiation to obtain a gradient.</p><p><code>kind</code> is usually a <code>Val</code> type with a symbol that refers to a package, for example</p><pre><code class="language-julia">ADgradient(Val(:ForwardDiff), P)</code></pre><p>The symbol can also be used directly as eg</p><pre><code class="language-julia">ADgradient(:ForwardDiff, P)</code></pre><p>and should mostly be equivalent if the compiler manages to fold the constant.</p><p><code>parent</code> can be used to retrieve the original argument.</p><p>See <code>methods(ADgradient)</code>. Note that <strong>some methods are defined conditionally on the relevant package being loaded.</strong></p></div></div><a class="source-link" target="_blank" href="https://github.com/tpapp/LogDensityProblems.jl/blob/d7a3e8e82f6090efca84668764e767e10a463c2f/src/LogDensityProblems.jl#L193">source</a><div><div><pre><code class="language-julia">ADgradient(#temp#, ℓ; chunk, gradientconfig)
</code></pre><p>Wrap a log density that supports evaluation of <code>Value</code> to handle <code>ValueGradient</code>, using <code>ForwardDiff</code>.</p><p>Keywords are passed on to <code>ForwardDiff.GradientConfig</code> to customize the setup. In particular, chunk size can be set with a <code>chunk</code> keyword argument (accepting an integer or a <code>ForwardDiff.Chunk</code>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/tpapp/LogDensityProblems.jl/blob/d7a3e8e82f6090efca84668764e767e10a463c2f/src/AD_ForwardDiff.jl#L31">source</a><div><div><pre><code class="language-julia">ADgradient(?, ℓ)
</code></pre><p>Gradient using algorithmic/automatic differentiation via Flux.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tpapp/LogDensityProblems.jl/blob/d7a3e8e82f6090efca84668764e767e10a463c2f/src/AD_Flux.jl#L11">source</a></section><p>Note that support for Zygote is experimental. At the moment, I would recommend that you use <code>Flux</code>.</p><p>Now observe that we can obtain gradients, too:</p><pre><code class="language-julia-repl">julia&gt; import ForwardDiff

julia&gt; ∇ℓ = ADgradient(:ForwardDiff, ℓ)
ERROR: UndefVarError: ℓ not defined

julia&gt; LogDensityProblems.capabilities(∇ℓ)
ERROR: UndefVarError: ∇ℓ not defined

julia&gt; LogDensityProblems.logdensity_and_gradient(∇ℓ, zeros(2))
ERROR: UndefVarError: ∇ℓ not defined</code></pre><h2><a class="nav-anchor" id="Manually-calculated-derivatives-1" href="#Manually-calculated-derivatives-1">Manually calculated derivatives</a></h2><p>If you prefer not to use automatic differentiation, you can wrap your own derivatives following the template</p><pre><code class="language-julia">function LogDensityProblems.capabilities(::Type{&lt;:NormalPosterior})
    LogDensityProblems.LogDensityOrder{1}() # can do gradient
end

LogDensityProblems.dimension(::NormalPosterior) = 2 # for this problem

function LogDensityProblems.logdensity_and_gradient(problem::NormalPosterior, x)
    logdens = ...
    grad = ...
    logdens, grad
end</code></pre><h1><a class="nav-anchor" id="Various-utilities-1" href="#Various-utilities-1">Various utilities</a></h1><p>You may find these utilities useful for debugging and optimization.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LogDensityProblems.stresstest" href="#LogDensityProblems.stresstest"><code>LogDensityProblems.stresstest</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">stresstest(f, ℓ; N, rng, scale)
</code></pre><p>Test <code>ℓ</code> with random values.</p><p><code>N</code> random vectors are drawn from a standard multivariate Cauchy distribution, scaled with <code>scale</code> (which can be a scalar or a conformable vector).</p><p>Each random vector is then used as an argument in <code>f(ℓ, ...)</code>. <code>logdensity</code> and <code>logdensity_and_gradient</code> are  recommended for <code>f</code>.</p><p>In case the call produces an error, the value is recorded as a failure, which are returned by the function.</p><p>Not exported, but part of the API.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tpapp/LogDensityProblems.jl/blob/d7a3e8e82f6090efca84668764e767e10a463c2f/src/LogDensityProblems.jl#L242">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LogDensityProblems.benchmark_ForwardDiff_chunks" href="#LogDensityProblems.benchmark_ForwardDiff_chunks"><code>LogDensityProblems.benchmark_ForwardDiff_chunks</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">benchmark_ForwardDiff_chunks(ℓ; chunks, markprogress, x)
</code></pre><p>Benchmark a log density problem with various chunk sizes using ForwardDiff.</p><p><code>chunks</code>, which defaults to all possible chunk sizes, determines the chunks that are tried.</p><p>The function returns <code>chunk =&gt; time</code> pairs, where <code>time</code> is the benchmarked runtime in seconds, as determined by <code>BenchmarkTools.@belapsed</code>. The gradient is evaluated at <code>x</code> (defaults to zeros).</p><p><em>Runtime may be long</em> because of tuned benchmarks, so when <code>markprogress == true</code> (the default), dots are printed to mark progress.</p><p>This function is not exported, but part of the API when <code>ForwardDiff</code> is imported.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tpapp/LogDensityProblems.jl/blob/d7a3e8e82f6090efca84668764e767e10a463c2f/src/AD_ForwardDiff.jl#L68">source</a></section><h1><a class="nav-anchor" id="log-density-api-1" href="#log-density-api-1">Log densities API</a></h1><p>Use the functions below for evaluating gradients and querying their dimension and other information. These symbols are not exported, as they are mostly used by package developers and in any case would need to be <code>import</code>ed or qualified to add methods to.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LogDensityProblems.capabilities" href="#LogDensityProblems.capabilities"><code>LogDensityProblems.capabilities</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">capabilities(T)
</code></pre><p>Test if the type (or a value, for convenience) supports the log density interface.</p><p>When <code>nothing</code> is returned, it doesn&#39;t support this interface.  When <code>LogDensityOrder{K}()</code> is returned (typically with <code>K == 0</code> or <code>K = 1</code>), derivatives up to order <code>K</code> are supported. <em>All other return values are invalid</em>.</p><p><strong>Interface description</strong></p><p>The following methods need to be implemented for the interface:</p><ol><li><p><a href="#LogDensityProblems.dimension"><code>dimension</code></a> returns the <em>dimension</em> of the domain,</p></li><li><p><a href="#LogDensityProblems.logdensity"><code>logdensity</code></a> evaluates the log density at a given point.</p></li><li><p><a href="#LogDensityProblems.logdensity_and_gradient"><code>logdensity_and_gradient</code></a> when <code>K ≥ 1</code>.</p></li></ol><p>See also <a href="#LogDensityProblems.stresstest"><code>LogDensityProblems.stresstest</code></a> for stress testing.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tpapp/LogDensityProblems.jl/blob/d7a3e8e82f6090efca84668764e767e10a463c2f/src/LogDensityProblems.jl#L47">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LogDensityProblems.LogDensityOrder" href="#LogDensityProblems.LogDensityOrder"><code>LogDensityProblems.LogDensityOrder</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct LogDensityOrder{K}</code></pre><p>A trait that means that a log density supports evaluating derivatives up to order <code>K</code>.</p><p>Typical values for <code>K</code> are <code>0</code> (just the log density) and <code>1</code> (log density and gradient).</p></div></div><a class="source-link" target="_blank" href="https://github.com/tpapp/LogDensityProblems.jl/blob/d7a3e8e82f6090efca84668764e767e10a463c2f/src/LogDensityProblems.jl#L28">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LogDensityProblems.dimension" href="#LogDensityProblems.dimension"><code>LogDensityProblems.dimension</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">dimension(ℓ)</code></pre><p>Dimension of the input vectors <code>x</code> for log density <code>ℓ</code>. See <a href="#LogDensityProblems.logdensity"><code>logdensity</code></a>, <a href="#LogDensityProblems.logdensity_and_gradient"><code>logdensity_and_gradient</code></a>.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>This function is <em>distinct</em> from <code>TransformedVariables.dimension</code>.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/tpapp/LogDensityProblems.jl/blob/d7a3e8e82f6090efca84668764e767e10a463c2f/src/LogDensityProblems.jl#L72-L80">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LogDensityProblems.logdensity" href="#LogDensityProblems.logdensity"><code>LogDensityProblems.logdensity</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">logdensity(ℓ, x)</code></pre><p>Evaluate the log density <code>ℓ</code> at <code>x</code>, which has length compatible with its <a href="#LogDensityProblems.dimension"><code>dimension</code></a>.</p><p>Return a real number, which may or may not be finite (can also be <code>NaN</code>). Non-finite values other than <code>-Inf</code> are invalid but do not error, caller should deal with these appropriately.</p><p><strong>Note about constants</strong></p><p>Log densities can be shifted by <em>the same constant</em>, as long as it is consistent between calls. For example,</p><pre><code class="language-julia">logdensity(::StandardMultivariateNormal) = -0.5 * sum(abs2, x)</code></pre><p>is a valid implementation for some callable <code>StandardMultivariateNormal</code> that would implement the standard multivariate normal distribution (dimension <span>$k$</span>) with pdf</p><div>\[(2\pi)^{-k/2} e^{-x&#39;x/2}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/tpapp/LogDensityProblems.jl/blob/d7a3e8e82f6090efca84668764e767e10a463c2f/src/LogDensityProblems.jl#L83-L106">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LogDensityProblems.logdensity_and_gradient" href="#LogDensityProblems.logdensity_and_gradient"><code>LogDensityProblems.logdensity_and_gradient</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">logdensity_and_gradient(ℓ, x)</code></pre><p>Evaluate the log density <code>ℓ</code> and its gradient at <code>x</code>, which has length compatible with its <a href="#LogDensityProblems.dimension"><code>dimension</code></a>.</p><p>Return two values:</p><ul><li><p>the log density as real number, which equivalent to <code>logdensity(ℓ, x)</code></p></li><li><p><em>if</em> the log density is finite, the gradient, a vector of real numbers, otherwise this  value is arbitrary and should be ignored.</p></li></ul><p>The first argument (the log density) can be shifted by a constant, see the note for <a href="#LogDensityProblems.logdensity"><code>logdensity</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/tpapp/LogDensityProblems.jl/blob/d7a3e8e82f6090efca84668764e767e10a463c2f/src/LogDensityProblems.jl#L109-L124">source</a></section><footer><hr/></footer></article></body></html>
